<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Health Snakes and Ladders - Interactive</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            user-select: none;
        }

        h1 { margin-bottom: 10px; }

        #game-layout {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        /* Container for the static board image */
        #board-container {
            position: relative;
            width: 768px; /* Standard size based on the image ratio */
            height: 768px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            border: 2px solid #ccc;
            overflow: hidden;
            background-color: white;
        }

        #board-img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        /* Player tokens - circles that will be positioned on the grid */
        .player-token {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            transition: all 0.3s ease-out; /* Smooth movement animation */
            z-index: 10;
            display: none; /* Hidden until game starts */
        }

        /* Player colors - distinctly different from the board colors */
        #player1 { background-color: cyan; border-color: black; }
        #player2 { background-color: purple; }
        #player3 { background-color: orange; }

        /* Small offset for multiple tokens on one square */
        .token-0 { transform: translate(-5px, -5px); }
        .token-1 { transform: translate(5px, 5px); }
        .token-2 { transform: translate(-5px, 5px); }

        /* Control Panel */
        #controls {
            width: 250px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        h3 { margin-top: 0; }

        .player-list {
            list-style: none;
            padding: 0;
        }

        .player-item {
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .current-turn {
            border-color: #4CAF50;
            background-color: #e8f5e9;
            font-weight: bold;
        }

        .color-sample {
            display: inline-block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        #p1-color { background-color: cyan; border: 1px solid black; }
        #p2-color { background-color: purple; }
        #p3-color { background-color: orange; }

        #dice-container {
            margin-top: 20px;
            text-align: center;
        }

        #dice-value {
            font-size: 3em;
            margin: 10px 0;
            min-height: 1.2em;
        }

        #roll-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1.2em;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        #roll-btn:hover { background-color: #45a049; }
        #roll-btn:disabled { background-color: #ccc; cursor: not-allowed; }

        #status-display {
            margin-top: 20px;
            font-size: 0.9em;
            color: #555;
            min-height: 1.5em;
        }

        /* Victory state */
        .victory #board-img { opacity: 0.5; }
        .victory::after {
            content: "GAME OVER";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-15deg);
            font-size: 5em;
            color: gold;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 100;
        }

    </style>
</head>
<body>

    <h1>Interactive Health Board Game</h1>

    <div id="game-layout">
        <div id="board-container">
            <img id="board-img" src="health_board.png" alt="Health Snakes and Ladders Board">
            <div id="player1" class="player-token"></div>
            <div id="player2" class="player-token"></div>
            <div id="player3" class="player-token"></div>
        </div>

        <div id="controls">
            <h3>Game Controls</h3>
            <ul class="player-list">
                <li id="p1-info" class="player-item current-turn">
                    <span id="p1-color" class="color-sample"></span>
                    <span>Player 1 (Square: <span id="p1-pos">1</span>)</span>
                </li>
                <li id="p2-info" class="player-item">
                    <span id="p2-color" class="color-sample"></span>
                    <span>Player 2 (Square: <span id="p2-pos">1</span>)</span>
                </li>
                <li id="p3-info" class="player-item">
                    <span id="p3-color" class="color-sample"></span>
                    <span>Player 3 (Square: <span id="p3-pos">1</span>)</span>
                </li>
            </ul>

            <div id="dice-container">
                <div>Dice Roll:</div>
                <div id="dice-value">?</div>
                <button id="roll-btn">Roll Dice</button>
            </div>

            <p id="status-display">Click 'Roll Dice' to begin.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- CONFIGURATION & DATA ---
            const TOTAL_SQUARES = 71;
            const GRID_COLS = 9;
            const GRID_ROWS = 8;
            // Define specific snakes and ladders based on the original image logic
            // (Start square -> End square)
            const snakes = { 70: 59, 68: 16, 67: 52, 62: 43, 58: 12, 35: 33 };
            const ladders = { 2: 25, 8: 21, 23: 37, 30: 44, 46: 54, 51: 66 };

            // Grid coordinate mapping (calculates percentage X,Y for each square center)
            const getCoordinatesForSquare = (squareNumber) => {
                if (squareNumber < 1 || squareNumber > TOTAL_SQUARES) return { x: 0, y: 0 };
                const index = squareNumber - 1; // 0-indexed
                const row = Math.floor(index / GRID_COLS);
                let col;

                // Adjust for the standard boustrophedon (snake-like) pattern of grid numbering
                if (row % 2 === 0) { // Bottom row (1-9) and alternating up are normal
                    col = index % GRID_COLS;
                } else { // Even numbered rows (10-18) are reversed
                    col = (GRID_COLS - 1) - (index % GRID_COLS);
                }

                // Invert the row because square 1 is at the BOTTOM of the visual board
                const visualRow = (GRID_ROWS - 1) - row;

                // Return coordinates in PERCENTAGE of container size (X%, Y%)
                // This makes the positioning responsive.
                // Square center logic: (index + 0.5) / num_cols * 100
                return {
                    x: ((col + 0.5) / GRID_COLS) * 100,
                    y: ((visualRow + 0.5) / GRID_ROWS) * 100
                };
            };


            // --- GAME STATE ---
            let players = [
                { id: 0, pos: 1, element: document.getElementById('player1'), posEl: document.getElementById('p1-pos'), infoEl: document.getElementById('p1-info') },
                { id: 1, pos: 1, element: document.getElementById('player2'), posEl: document.getElementById('p2-pos'), infoEl: document.getElementById('p2-info') },
                { id: 2, pos: 1, element: document.getElementById('player3'), posEl: document.getElementById('p3-pos'), infoEl: document.getElementById('p3-info') }
            ];
            let currentPlayerIndex = 0;
            let gameActive = true;

            const rollBtn = document.getElementById('roll-btn');
            const diceValueDisplay = document.getElementById('dice-value');
            const statusDisplay = document.getElementById('status-display');
            const boardContainer = document.getElementById('board-container');


            // --- INITIALIZATION ---
            // Place all tokens at start (hidden but ready)
            players.forEach((player, index) => {
                player.element.style.display = 'block'; // Show now
                const coords = getCoordinatesForSquare(player.pos);
                updateTokenPosition(player, coords.x, coords.y);
                // Also add small offset class for shared squares
                player.element.classList.add(`token-${index}`);
            });


            // --- CORE FUNCTIONALITY ---

            // Utility to move a token element to given percentage coordinates
            function updateTokenPosition(player, xPerc, yPerc) {
                // We use center-point positioning, but need to offset by token half-size.
                // It's simpler to set top/left as percentage, then use `transform: translate(-50%, -50%)`
                // in CSS. *Wait*, CSS currently uses small offset transform. Let's make it more robust.
                // We'll calculate the top/left *center* point. The CSS `transform` already adds the offset.
                player.element.style.left = `${xPerc}%`;
                player.element.style.top = `${yPerc}%`;
                player.element.style.transform = `translate(-50%, -50%)`; // Keep it centered on point
                // Note: The offset classes (.token-0, etc.) from CSS will now be redundant, we can remove them for cleaner positioning.
                // Let's add them back, but as simple offsets in px or em via JS or separate rule. For now, centering is best.
                // Let's remove the offset classes from HTML/CSS for cleaner centering for now.
            }

            // A slightly more complex move that *visualizes* the path square-by-square.
            async function movePlayerStepByStep(player, targetPos) {
                const currentPos = player.pos;

                // Move one step at a time for 'hopping' effect
                for (let nextPos = currentPos + 1; nextPos <= targetPos; nextPos++) {
                    const coords = getCoordinatesForSquare(nextPos);
                    updateTokenPosition(player, coords.x, coords.y);
                    player.pos = nextPos;
                    player.posEl.textContent = player.pos;
                    await new Promise(r => setTimeout(r, 150)); // Wait for animation (e.g., 0.15s)
                }
            }


            async function handleTurn() {
                if (!gameActive) return;

                const player = players[currentPlayerIndex];
                rollBtn.disabled = true; // Block clicking while moving
                statusDisplay.textContent = `Player ${player.id + 1} rolling...`;

                // 1. Roll Dice (simple and fast animation)
                let roll;
                let rolls = [1, 2, 3, 4, 5, 6, 2, 4];
                let i = 0;
                let diceAnim = setInterval(() => {
                    diceValueDisplay.textContent = rolls[i % rolls.length];
                    i++;
                }, 50);

                await new Promise(r => setTimeout(r, 500)); // Show rolling animation for 0.5s
                clearInterval(diceAnim);

                roll = Math.floor(Math.random() * 6) + 1;
                diceValueDisplay.textContent = roll;
                diceValueDisplay.style.color = 'inherit'; // Reset any past win coloring

                // 2. Calculate next position
                let newPos = player.pos + roll;

                // Check for win condition (MUST land exactly on TOTAL_SQUARES)
                // In many simple implementations, you can win by rolling OVER,
                // but for educational accuracy, exact landing is standard for "Goal".
                if (newPos > TOTAL_SQUARES) {
                    statusDisplay.textContent = `Player ${player.id + 1} rolled a ${roll} but needed a ${TOTAL_SQUARES - player.pos} to reach Square ${TOTAL_SQUARES}. Position stays.`;
                    await new Promise(r => setTimeout(r, 500)); // Show this text briefly
                } else if (newPos === TOTAL_SQUARES) {
                    // Winning move:
                    await movePlayerStepByStep(player, newPos);
                    statusDisplay.textContent = `*** CONGRATULATIONS! Player ${player.id + 1} reached the GOAL! ***`;
                    statusDisplay.style.fontWeight = "bold";
                    diceValueDisplay.textContent = 'â˜…'; // Victory marker
                    diceValueDisplay.style.color = 'gold';
                    boardContainer.classList.add('victory');
                    gameActive = false;
                    return; // Stop turn sequence
                } else {
                    // Regular move:
                    statusDisplay.textContent = `Player ${player.id + 1} rolls ${roll}, moves from ${player.pos} to ${newPos}.`;
                    await movePlayerStepByStep(player, newPos); // Move to the target square
                }


                // 3. Check for Snakes and Ladders
                // Re-evaluate if we are on a special square. We only do this IF we didn't land exactly on victory.
                let targetPosAfterFeature = player.pos;
                let featureType = null;

                if (snakes[targetPosAfterFeature]) {
                    targetPosAfterFeature = snakes[targetPosAfterFeature];
                    featureType = 'SNAKE';
                    statusDisplay.textContent = `Oh no! A snake from ${player.pos} down to ${targetPosAfterFeature}. (Negative Health Behavior)`;
                    statusDisplay.style.color = '#c62828'; // Red for negative

                } else if (ladders[targetPosAfterFeature]) {
                    targetPosAfterFeature = ladders[targetPosAfterFeature];
                    featureType = 'LADDER';
                    statusDisplay.textContent = `Great! A ladder from ${player.pos} up to ${targetPosAfterFeature}. (Positive Health Behavior!)`;
                    statusDisplay.style.color = '#2e7d32'; // Green for positive
                }

                if (featureType) {
                    await new Promise(r => setTimeout(r, 700)); // Wait before moving again

                    // Smooth 'ride' animation. Instead of hopping, just move smoothly.
                    const finalCoords = getCoordinatesForSquare(targetPosAfterFeature);
                    updateTokenPosition(player, finalCoords.x, finalCoords.y);
                    player.pos = targetPosAfterFeature;
                    player.posEl.textContent = player.pos;

                    await new Promise(r => setTimeout(r, 600)); // Wait for 'ride' to finish
                    statusDisplay.style.color = 'inherit'; // Reset status color
                }


                // 4. Pass Turn
                if (gameActive) {
                    // Remove current active highlight
                    player.infoEl.classList.remove('current-turn');

                    // Increment or loop player index
                    currentPlayerIndex = (currentPlayerIndex + 1) % players.length;

                    // Add highlight to new player
                    const nextPlayer = players[currentPlayerIndex];
                    nextPlayer.infoEl.classList.add('current-turn');

                    statusDisplay.textContent = `Player ${nextPlayer.id + 1}'s Turn.`;
                    rollBtn.disabled = false;
                }
            }


            // --- EVENT LISTENERS ---
            rollBtn.addEventListener('click', handleTurn);

        });
    </script>
</body>
</html>
